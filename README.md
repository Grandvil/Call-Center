# Колл-центр

## Описание задачи
Мы начали заниматься организацией техподдержки у одного из провайдеров города. К нам поступают звонки от разных абонентов, а мы силами нескольких специалистов эти звонки "разбираем".

### Работа программы
1. Создание и запуск потоков-специалистов и один поток-АТС (генерирует звонки)
2. Поток-АТС после запуска начинает генерировать несколько (например, 60) "звонков" раз в 1 секунду
3. Потоки-специалисты берут доступные звонки в работу
4. Методом `Thread.sleep()` реализуется эмуляция работы специалиста над вопросом (3-4 секунды, например)
5. Главный поток (main) ждет конца выполнения всех потоков

### Требования к программе
1. Никаких блокировок. Вся работа должна основываться на concurrent-коллекциях
2. Все константы должны быть оформлены как константы (никаких "Магических чисел")

### Пояснения к выбору коллекции
Выбор ArrayBlockingQueue для решения задачи колл-центра был обусловлен следующими факторами:

1. Ограниченное количество элементов в очереди:
  - Задача предполагает, что количество звонков, ожидающих обработки, ограничено (CALLS_COUNT). ArrayBlockingQueue идеально подходит для этой ситуации, так как он хранит элементы в фиксированном массиве заданного размера. 
  - Если бы задача требовала неограниченное количество звонков, LinkedBlockingQueue был бы лучшим выбором, так как он использует связный список для хранения элементов и не имеет ограничений по размеру.

2. Атомарность операций:
  - ArrayBlockingQueue предоставляет атомарные операции put() и take(). Это означает, что доступ к очереди блокируется до тех пор, пока операция не будет завершена, предотвращая возникновение таких проблем, когда, например, специалист может получать звонок, который еще не был добавлен в очередь. 
  - ArrayBlockingQueue гарантирует корректность работы программы без необходимости явной синхронизации с помощью synchronized или ReentrantLock.

3. Эффективность:
  - ArrayBlockingQueue является более эффективным, чем LinkedBlockingQueue в задачах, где размер очереди ограничен. Это связано с тем, что он использует массив для хранения элементов, что обеспечивает более быстрый доступ к данным. 